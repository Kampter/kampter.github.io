<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习笔记 on RyanCV - CV Resume &amp; vCard Hugo Theme</title><link>https://kampter.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><description>Recent content in 学习笔记 on RyanCV - CV Resume &amp; vCard Hugo Theme</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Apr 2023 20:25:54 +0800</lastBuildDate><atom:link href="https://kampter.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>URP屏幕空间Sobel边缘检测</title><link>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4sobel%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</link><pubDate>Wed, 05 Apr 2023 20:25:54 +0800</pubDate><guid>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4sobel%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</guid><description>什么是边缘检测 根据Wiki说明，边缘检测是一种用于识别图像变化的明显的区域的技术。因此这种基础技术被广泛应用与图像处理和计算机视觉中用以查找出物体的边缘。边缘检测算法的目的是发掘图像中不连续火图像亮度急剧变化的点。而常见的几种算法用于便边缘检测技术包括Sobel， Prewitt, Roberts 和 Canny。其中Canny 边缘检测器是罪被广泛应用的算法，它使用多阶算法结合，于1986年被John F. Canny最先开发出来并且随后广泛使用。
为什么边缘检测重要 边缘检测是图像处理的重要组成部分，因为它有助于计算识别和将图像分离成不同的部分 。 它用于图像处理、计算机视觉和机器视觉等领域的图像分割和数据提取。 检测图像亮度的急剧变化的目的是捕捉重要事件和属性的变化。 边缘是与图像相关的最重要的特征之一。 我们通过图像的边缘了解图像的底层结构。 因此，计算机视觉处理管道广泛使用边缘检测。
Sobel 边缘检测 简单地说，我们对每个片段的四个边邻居进行采样，并对采样属性的差异求和。 小的差异表明表面是一致的，我们很可能不在边缘上，而大的差异表明采样属性的突然变化，我们很可能在边缘像素上。</description></item><item><title>blender插件制作心得</title><link>https://kampter.github.io/blog/blender%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%BF%83%E5%BE%97/</link><pubDate>Wed, 05 Apr 2023 15:36:05 +0800</pubDate><guid>https://kampter.github.io/blog/blender%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E5%BF%83%E5%BE%97/</guid><description>前言 一个偶然的机会接触到 Blender插件编写，一直以来我都是(曾经是) Maya以及Houdini软件的拥护者，但是Blender 的开源社区逐渐壮大也不能不引起重视，那么是时候了解一下Blender的相关内容。
Blender的交互层都是用Python来编写的，这就相当友好了。作为一个使用过python用来数据分析以及编写爬虫爬 *** 内容的人表示这很开心。
基础模板 bl_info = { &amp;#34;name&amp;#34;: &amp;#34;HelloAddon&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;作者&amp;#34;, &amp;#34;version&amp;#34;: (1, 0), &amp;#34;blender&amp;#34;: (2, 79, 0), &amp;#34;location&amp;#34;: &amp;#34;View3D &amp;gt; Tool Shelf &amp;gt;HelloAddon Panel&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;插件描述&amp;#34;, &amp;#34;warning&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;wiki_url&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;3D View&amp;#34;, } import bpy import logging from .</description></item><item><title>URP屏幕空间环境光遮蔽</title><link>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/</link><pubDate>Wed, 05 Apr 2023 14:35:17 +0800</pubDate><guid>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/</guid><description>Screen Space Ambient Occlusion: Enhancing Realism in Video Games Introduction Video games have come a long way since their inception, and the quality of graphics has improved significantly.</description></item><item><title>URP屏幕空间雾效</title><link>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E9%9B%BE%E6%95%88/</link><pubDate>Tue, 04 Apr 2023 14:25:03 +0800</pubDate><guid>https://kampter.github.io/blog/urp%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E9%9B%BE%E6%95%88/</guid><description>Unity URP Depth Fog Introduction Unity is a powerful game engine that has been used by game developers around the world to create high-quality games with various tools and features.</description></item><item><title>URP 14 RenderFeature 使用方式</title><link>https://kampter.github.io/blog/urp-14-renderfeature-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 20 Mar 2023 10:47:50 +0000</pubDate><guid>https://kampter.github.io/blog/urp-14-renderfeature-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid><description>URP 14 URP 14 对应Unity 2022.2对于2021lts版本的URP 12中后处理的API有些许改变，需要参考官方文档的改变。而其中最大的改变来自于RTHandle的引入。
以一个DesaturateFeature为例。在DesaturateFeature.cs中改变比较大的是加入一个SetupRenderPasses来帮助创建Materail和传递参数，而不是传统的写法在Create()中。
public override void SetupRenderPasses(ScriptableRenderer renderer, in RenderingData renderingData) { Material material = CoreUtils.</description></item><item><title>Games 101 - 光栅化</title><link>https://kampter.github.io/blog/games-101-%E5%85%89%E6%A0%85%E5%8C%96/</link><pubDate>Fri, 02 Sep 2022 15:48:07 +0000</pubDate><guid>https://kampter.github.io/blog/games-101-%E5%85%89%E6%A0%85%E5%8C%96/</guid><description>前言：只记录自己需要的内容
光栅化 屏幕空间 从（0，0）到（width, height）
光栅化的过程即采样过程，来判断屏幕上的像素点是否在三角形里面
采样的缺点：以点代面，有失偏颇 → Aliasing 走样，表现为锯齿
引入傅里叶变换，采样信息可以分解成函数表达
高频信息：简单来说就是outline边界，边界变化带来巨大的图像效果变化
只保留高频信息：表现为边缘部分
只保留低频信息：表现为画面主体
走样 走样就是采样的中出现重复或者没有采集到关键信息 （图中蓝色和黑色采样点相同，但是实际差距明显）
减少Aliasing Error 的方法</description></item></channel></rss>